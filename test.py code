# colab í™˜ê²½ì—ì„œ ì‘ë™í•˜ê²Œë” ì„¤ê³„í•œ ê²ƒì…ë‹ˆë‹¤
# ëª¨ë¸ ì ìš© ë° êµ¬í˜„ ë‚´ìš© íŒŒì•…ì„ ìœ„í•œ í…ŒìŠ¤íŠ¸ìš© ì½”ë“œì…ë‹ˆë‹¤
# ì§ì ‘ ìš”ì•½ì€ ì œëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤

# í•„ìš” íŒ¨í‚¤ì§€ë“¤ì…ë‹ˆë‹¤
# pip install torch requests ipywidgets transformers sentencepiece

import requests
from urllib.parse import quote

import torch
from transformers import AutoModelForSeq2SeqLM, AutoTokenizer

import ipywidgets as widgets
from IPython.display import display, clear_output

import itertools
import random

# ëª¨ë¸ ë¡œë“œ
hf_token = "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"  # ê°œì¸ Hugging Face token
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model_name = "wisenut/KoT5-base"
tokenizer = AutoTokenizer.from_pretrained("wisenut-nlp-team/KoT5-base", token=hf_token)
model = AutoModelForSeq2SeqLM.from_pretrained("wisenut-nlp-team/KoT5-base", token=hf_token)

# ìš”ì•½ í•¨ìˆ˜ ì •ì˜
"""def generate_summary(input_text, model, tokenizer, max_new_tokens, num_lines):
    sentences = input_text.split("\n")
    num_sentences = len(sentences)
    summary_parts = []

    for i in range(0, num_sentences, max_new_tokens):
        part = " ".join(sentences[i : i + max_new_tokens])
        # ìì—°ì–´ í”„ë¡¬í”„íŠ¸ì— ì¤„ ìˆ˜ ëª…ì‹œ
        prefix = f"summarize: ë‹¤ìŒ ë¬¸ì„œë¥¼ {num_lines}ì¤„ë¡œ ìš”ì•½í•´ì¤˜. " + part
        token = tokenizer.encode(prefix, return_tensors="pt", max_length=512, truncation=True)
        token = token.to(device)
        output = model.generate(input_ids=token, max_new_tokens=max_new_tokens, num_return_sequences=1)
        summary_part = tokenizer.decode(output[0], skip_special_tokens=True)
        summary_parts.append(summary_part)

    # ì‘ì€ ë¬¸ì¥ë“¤ì˜ ìš”ì•½ì„ í•©ì³ì„œ ì „ì²´ ë¬¸ì¥ì˜ ìš”ì•½ ìƒì„±
    full_summary = " ".join(summary_parts)
    return full_summary"""

# ìš”ì•½ í•¨ìˆ˜ ì •ì˜
def generate_summary(input_text, model, tokenizer, max_new_tokens):
    inputs = tokenizer.encode(input_text, return_tensors="pt", max_length=512, truncation=True).to(device)
    summary_ids = model.generate(inputs, max_new_tokens=max_new_tokens, num_return_sequences=1)
    summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    return summary

# ë„¤ì´ë²„ api í‚¤ ë° ì¶”ì²œ ì±…
client_id = 'crmFhpIDo84nKGVPAFnp'
client_secret = 'IbfZJb0j1v'
display_count = 5  # ê²€ìƒ‰ì–´ë‹¹ ê°€ì ¸ì˜¬ ì±… ìˆ˜

# ì±… ì¶”ì²œ í•¨ìˆ˜
def fetch_books(query, display=5):
    start = random.randint(1, 50)  # ê²€ìƒ‰ ì‹œì‘ ìœ„ì¹˜ë¥¼ 1~50 ì‚¬ì´ë¡œ ëœë¤ ì„¤ì • (API ì œí•œì€ 1000ê±´, í•œ í˜ì´ì§€ 10ê±´)
    url = f"https://openapi.naver.com/v1/search/book.json?query={quote(query)}&display={display}&start={start}"
    headers = {
        "X-Naver-Client-Id": client_id,
        "X-Naver-Client-Secret": client_secret
    }
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return response.json().get("items", [])
    else:
        print(f"âŒ API í˜¸ì¶œ ì‹¤íŒ¨({response.status_code}): {query}")
        return []

# ì±… ì¶”ì²œ ì •ë³´ ì¶œë ¥ í•¨ìˆ˜
def show_recommendations(queries, display=3):
    with output_area:
        clear_output()
        for query in queries:
            print(f"\nğŸ” ê²€ìƒ‰ì–´: '{query}'")
            books = fetch_books(query, display)
            if books:
                for i, book in enumerate(books):
                    print(f"\nğŸ“˜ {i+1}. ì œëª©: {book['title']}")
                    print(f"âœï¸ ì €ì: {book['author']}")
                    print(f"ğŸ¢ ì¶œíŒì‚¬: {book['publisher']}")
                    print(f"ğŸ“„ ì„¤ëª…: {book['description'][:150]}...")
            else:
                print("âš ï¸ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")

# ë„¤ì´ë²„ apië¥¼ ì ìš©í•´ ì±… ì •ë³´ë¥¼ ê²€ìƒ‰ ë° ìš”í•˜ëŠ” í•¨ìˆ˜
def search_and_summarize_book(book_title, max_tokens):
    url = f"https://openapi.naver.com/v1/search/book.json?query={quote(book_title)}"
    headers = {
        "X-Naver-Client-Id": client_id,
        "X-Naver-Client-Secret": client_secret
    }

    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        items = response.json().get('items')
        if items:
            book = items[0]
            title = book['title']
            author = book['author']
            publisher = book['publisher']
            description = book['description']
            summary = generate_summary(description, model, tokenizer, max_tokens)

            return {
                "title": title,
                "author": author,
                "publisher": publisher,
                "description": description,
                "summary": summary
            }
        else:
            return {"error": "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."}
    else:
        return {"error": f"API í˜¸ì¶œ ì‹¤íŒ¨: {response.status_code}"}

# ğŸ”¹ ìµœìƒìœ„ ì»¨í…Œì´ë„ˆ ìƒì„±
container = widgets.VBox()

# UI êµ¬ì„±
query_input = widgets.Text(
    value='ì†Œì„¤, ê³¼í•™',
    placeholder='ì˜ˆ: ì†Œì„¤, ê³¼í•™',
    description='ì¶”ì²œ í‚¤ì›Œë“œ:',
    layout=widgets.Layout(width="70%")
)
recommend_button = widgets.Button(
    description='ì±… ì¶”ì²œ',
    button_style='success'
)

book_title_input = widgets.Text(
    value='',
    placeholder='ì˜ˆ: ë°ë¯¸ì•ˆ',
    description='ì±… ì œëª©:',
    layout=widgets.Layout(width="50%")
)

line_count_slider = widgets.IntSlider(
    value=3,
    min=1,
    max=10,
    step=1,
    description='ìš”ì•½ ê¸¸ì´:',
    continuous_update=False
)

search_button = widgets.Button(
    description='ì±… ìš”ì•½ ìƒì„±',
    button_style='info'
)

mode_selector = widgets.ToggleButtons(
    options=['ğŸ“š ì±… ì¶”ì²œ ë°›ê¸°', 'ğŸ” ì±… ì§ì ‘ ìš”ì•½'],
    description='ëª¨ë“œ ì„ íƒ:',
    style={'button_color': '#ececec'}
)

output_area = widgets.Output()

# ğŸ”§ ëª¨ë“œ ì „í™˜ UI ê°±ì‹  í•¨ìˆ˜
def update_mode_ui(change):
    output_area.clear_output()
    if change['new'] == 'ğŸ“š ì±… ì¶”ì²œ ë°›ê¸°':
        container.children = [mode_selector, query_input, recommend_button, output_area]
    else:
        container.children = [mode_selector, book_title_input, line_count_slider, search_button, output_area]

# ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
def on_recommend_clicked(b):
    with output_area:
        clear_output()  # ğŸ”„ ê¸°ì¡´ ì¶œë ¥ ì‚­ì œ
        queries = [q.strip() for q in query_input.value.split(',') if q.strip()]
        if queries:
            show_recommendations(queries)
        else:
            print("âš ï¸ ìµœì†Œ 1ê°œì˜ í‚¤ì›Œë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")

# ë²„íŠ¼ ì´ë²¤íŠ¸
def on_search_clicked(b):
    with output_area:
        clear_output()
        title = book_title_input.value.strip()
        num_lines = line_count_slider.value
        max_tokens = num_lines * 25
        if title:
            print("ğŸ” ì±… ì •ë³´ ê²€ìƒ‰ ë° ìš”ì•½ ì¤‘ì…ë‹ˆë‹¤...\n")
            result = search_and_summarize_book(title, max_tokens)
            clear_output()
            if "error" in result:
                print("âš ï¸", result["error"])
            else:
                print(f"ğŸ“š ì œëª©: {result['title']}")
                print(f"âœï¸ ì €ì: {result['author']}")
                print(f"ğŸ¢ ì¶œíŒì‚¬: {result['publisher']}\n")
                print(f"ğŸ“„ ì›ë¬¸ ì„¤ëª…:\n{result['description']}\n")
                print("ğŸ“Œ ìš”ì•½ ê²°ê³¼:\n")
                print(result['summary'])
        else:
            print("âš ï¸ ì±… ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")

recommend_button.on_click(on_recommend_clicked)
search_button.on_click(on_search_clicked)
mode_selector.observe(update_mode_ui, names='value')

# ğŸ”½ ì´ˆê¸° UI ì„¤ì •
container.children = [mode_selector, query_input, recommend_button, output_area]
display(container)
